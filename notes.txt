todo:
dead units don't lose visibility if they were killed without ever moving
create & delete amplitude should be events
ring formation
doxygen-style comments
should Universe data be directly in Sim class?
remove floating point Sim calculations
replace DX.cs structs with classes and rename some vars?
PolyV2d.makeLineRec method?
pathfinding
darker gray tiles should act more conventionally

global variables:
visibility tiles = 2d array of:
  list of units currently seeing tile
coherence tiles = 2d array of:
  a 1d array (sorted by increasing time) of:
    time changed, faction w/ coherence here (may be no faction)
  index at current time
  last time lost visibility (not coherence) per faction (set to max value if currently visible)
decoherence queue = list or dict sorted by time of:
  tile pos, direction, faction, time to lose visibility (not coherence)
time variables:
  prev time, sim time, current time
  cap current time - sim time to a max amount

update units function:
for each unit:
  calculate time will reach next tile(s), if between prev time & current time then add to dict (key = time; value = unit, tile, direction)
sort dict by increasing time
for each unit in dict:
  add visiblity to tiles (including on coherence tiles), 1 tile "thick" on side of dict direction
  remove visibility from tiles, 1 tile "thick" on opposite side of dict direction
  if dict time > sim time:
    if another faction could see unit at prev tile but not this tile:
      add tile to decoherence queue for other faction
    init list of potential tiles in unit's visibility to cohere
      (note: doesn't work, some tiles that cohere are not directly visible)
    for each non-visible tile (according to coherence tiles) surrounding this unit:
      (note: doesn't work, doesn't consider other faction units that are allowed to be slightly more than minimum out of range of this unit's visibility)
      (note: can use this property to optimize coherence check: if neighboring tile is coherent, then only need to check "new" tiles that could see this tile)
      if unit w/ this unit's sight range (+ 1/2 tile length?) is here, remove tiles from list that this "unit" can see
    cohere remaining tiles in list (unless only remaining tile is the tile the unit is on)
    for each tile removed from:
      if no one in this faction sees this tile anymore:
        lose visibility time = lowest time each of surrounding 3 (up to 5) tiles lost visibility
        if lose visibility time or another faction's unit on this tile:
          lose visibility time += time it takes for light to travel 1 tile
          lose visibility time = max(dict time, lose visibility time)
          add tile to decoherence queue
for each entry in decoherence queue (loop through concurrently with loop above):
  if current time >= entry time:
    pop entry from queue
    if tile currently visible then continue
    set lose visibility time
    decohere tiles, 1 tile "thick" on side of entry direction, with radius of largest unit that faction can't see from here
    push entries into queue for each of the 8 surrounding tiles that are not visible to faction (according to visibility tiles) and can be traveled to
    note: correct to assume that all units can go at speed of light b/c can momentarily turn photon into particle & antiparticle

retroactive visibility temporary data:
"add vis" list item format:
  tile
  whether considered
  time neighboring tile gained visibility
"vis time" list item format: (note that items in this list already gained visibility at the correct time)
  tile
  time this tile gained visibility

retroactive visibility algorithm:
(might want to start making levels before implementing this)
(don't need global events for tile adds, since it all happens in 1 go)
add relevant tile to "add vis" list
while there's an unconsidered tile in "add vis" list:
  get tile w/ latest gain visibility time from list
  "gain visibility time" = latest time this tile gained visibility (using toggle visibility time is ok) that is <= list item time
  if all surrounding tiles are visible at gain visiblity time + 1 ("considered" tiles count as visible):
    (note: there's either a problem on above line or when adding original tile to list; if you quickly close "mouth" from back to front then current algorithm won't detect that more of "mouth" should be visible earlier; reminder to compare to losing visibility algorithm b/c that one is correct)
    // this tile should be visible earlier
    mark tile as "considered"
    add 8 surrounding tiles to "add vis" list, time being "gain visibility time"
    // note that we don't yet know whether surrounding tiles should be on "add vis" list or "vis time" list b/c must look at tiles in order
  else:
    // this tile shouldn't be visible earlier
    add to "vis time" list, time being "gain visibility time"
    remove from "add vis" list
while "vis time" list isn't empty:
  pop tile w/ earliest gain visibility time from list
  for each adjacent tile in "add vis" list:
    this tile gains visibility at time it takes to get between tiles
    add this tile to "vis time" list

pathfinding:
tile-based fog of war good?
find disconnected regions
path smoothing
would graph be too big?

other questions:
puzzle brainstorming
work on game in summer with Matthew and/or Zach, then email TJ when further along?

changing the past and wavefunctions levels:
- what they didn't see
  - Matthew's 3/17/2013 email has alternate idea for 1st level
- better than a coin flip
- spreading coherence (objective is to see the entire map)
  - user controls electrons, but some antiprotons on map
  - in q&a explain how nature controls/sees everything (1 player game) & how we measure it, interpretations of quantum mechanics
- retroactive coherence
- do I need another level to show applications of switching particles, or does 1st level show this well enough?
- somehow show how particle can be "coherent" even if not in yellow region
- make levels introducing economic parts of game after making sure they play well in multiplayer
...
- qubits? (might not need this level)
- lucky number computing
  - must introduce "waking up" concept before this level
- CPT level to annihilate the antiproton in negative 10 seconds (only enable CPT button for this level)
- thinking in the present
  - put introduction text in "what they didn't see" repeat
  - initially show detailed animation for each move command, then short animation retracing particle's movement every time after that

amplitudes levels: (find better synonym for "part 2" such as redux?)
- better than a coin flip, part 2
- spreading coherence, part 2
- retroactive coherence, part 2
- snipers

random notes:
- phrase from AI wisdom: "expand selection by radius"
- flip/mirror map for some players in multiplayer game
- only share amplitudes if option is checked for a selection of units (don't want units randomly disappearing out of nowhere)
  - if some wavefunctions don't overlap yet, send amplitudes going between those units
- after implementing amplitudes, fog of war would need nonstandard behavior if different units have different seeing radii
  - so engine (not just mod file) might as well give all units the same seeing radius
- don't bother with fastest unit going at light speed, so don't need to have relativity
  - if need it for 1 q&a video, use command line or mod option to enable it
- population limit? (or just make units expensive enough that you can't make too many)
- if 1 amplitude mining & 1 amplitude scouting and use miner's money to make a fighter and fighter decoheres, then miner must have been mining (not scouting)
- introduce amplitudes 1st, then introduce wavefunctions as amplitudes that go everywhere in a region? (skipping manual time travel)
  - but manual time travel is nice though
  - keep in mind hard to force using time travel in levels if can do amplitudes
- Matthew says have story or something to make game interesting for people not interested in "physics" q&a's
- unit type ideas (Matthew says using real life particles is bad idea)
  - don't need too many unit types b/c time travel & amplitudes already make the game interesting
  - can have ranged units with visible laser paths
    - except can only see own snipers' laser paths (from all possible snipers)
    - other units' range is less than vis radius, so would have decohered by the time they shoot (so ok for anyone to see laser path)
  - have few increments of health, so easier to switch with someone with same health
    - having a healer unit also makes switching units easier
  - can't have mines (they'd have to be visible to the opponent when in seeing range)
  - sniper unit that shoots further than visibility range (but can shoot units that other units see)
    - which sniper shot it?
    - reload slowly so not too powerful?
    - have checkbox to automatically delete amplitude if another player gets too close, so can surround snipers with worker amplitudes
  - Matthew's unit images can be pixellated to keep them simple
  - workers/miners with low/0 attack (use as "helpers" in levels)
    - make more interesting name for them?
  - marines (generic shooting unit)

links:
play ogg: http://christophermpark.blogspot.com/2009/06/how-to-stream-ogg-file-using.html
binary serialization: http://code.google.com/p/protobuf-net/
.net sockets: http://www.codeproject.com/Articles/10649/An-Introduction-to-Socket-Programming-in-NET-using
age of empires multiplayer: http://www.gamasutra.com/view/feature/3094/1500_archers_on_a_288_network_.php
ai war optimization (including multiplayer): http://christophermpark.blogspot.com/2009/06/optimizing-30000-ships-in-realtime-in-c.html
multiplayer debugging: http://gafferongames.com/networking-for-game-programmers/debugging-multiplayer-games/

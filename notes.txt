todo:
doxygen-style comments
replace Sim.cs structs with classes? (should Universe data be directly in Sim class?)
allow moving particles in past even if they decohere later (higher priority than retroactive visibility)
pathfinding

global variables:
visibility tiles = 2d array of:
  list of units currently seeing tile
coherence tiles = 2d array of:
  a 1d array (sorted by increasing time) of:
    time changed, faction w/ coherence here (may be no faction)
  index at current time
  last time lost visibility (not coherence) per faction (set to max value if currently visible)
decoherence queue = list or dict sorted by time of:
  tile pos, direction, faction, time to lose visibility (not coherence)
time variables:
  prev time, sim time, current time
  cap current time - sim time to a max amount

update units function:
for each unit:
  calculate time will reach next tile(s), if between prev time & current time then add to dict (key = time; value = unit, tile, direction)
sort dict by increasing time
for each unit in dict:
  add visiblity to tiles (including on coherence tiles), 1 tile "thick" on side of dict direction
  remove visibility from tiles, 1 tile "thick" on opposite side of dict direction
  if dict time > sim time:
    if another faction could see unit at prev tile but not this tile:
      add tile to decoherence queue for other faction
    init list of potential tiles in unit's visibility to cohere
      (note: doesn't work, some tiles that cohere are not directly visible)
    for each non-visible tile (according to coherence tiles) surrounding this unit:
      (note: doesn't work, doesn't consider other faction units that are allowed to be slightly more than minimum out of range of this unit's visibility)
      (note: can use this property to optimize coherence check: if neighboring tile is coherent, then only need to check "new" tiles that could see this tile)
      if unit w/ this unit's sight range (+ 1/2 tile length?) is here, remove tiles from list that this "unit" can see
    cohere remaining tiles in list (unless only remaining tile is the tile the unit is on)
    for each tile removed from:
      if no one in this faction sees this tile anymore:
        lose visibility time = lowest time each of surrounding 3 (up to 5) tiles lost visibility
        if lose visibility time or another faction's unit on this tile:
          lose visibility time += time it takes for light to travel 1 tile
          lose visibility time = max(dict time, lose visibility time)
          add tile to decoherence queue
for each entry in decoherence queue (loop through concurrently with loop above):
  if current time >= entry time:
    pop entry from queue
    if tile currently visible then continue
    set lose visibility time
    decohere tiles, 1 tile "thick" on side of entry direction, with radius of largest unit that faction can't see from here
    push entries into queue for each of the 8 surrounding tiles that are not visible to faction (according to visibility tiles) and can be traveled to
    note: correct to assume that all units can go at speed of light b/c can momentarily turn photon into particle & antiparticle

retroactive visibility temporary data:
"add vis" list item format:
  tile
  whether considered
  time neighboring tile gained visibility
"vis time" list item format: (note that items in this list already gained visibility at the correct time)
  tile
  time this tile gained visibility

retroactive visibility algorithm:
(might want to start making levels before implementing this)
(don't need global events for tile adds, since it all happens in 1 go)
add relevant tile to "add vis" list
while there's an unconsidered tile in "add vis" list:
  get tile w/ latest gain visibility time from list
  "gain visibility time" = latest time this tile gained visibility (using toggle visibility time is ok) that is <= list item time
  if all surrounding tiles are visible at gain visiblity time + 1 ("considered" tiles count as visible):
    (note: there's either a problem on above line or when adding original tile to list; if you quickly close "mouth" from back to front then current algorithm won't detect that more of "mouth" should be visible earlier; reminder to compare to losing visibility algorithm b/c that one is correct)
    // this tile should be visible earlier
    mark tile as "considered"
    add 8 surrounding tiles to "add vis" list, time being "gain visibility time"
    // note that we don't yet know whether surrounding tiles should be on "add vis" list or "vis time" list b/c must look at tiles in order
  else:
    // this tile shouldn't be visible earlier
    add to "vis time" list, time being "gain visibility time"
    remove from "add vis" list
while "vis time" list isn't empty:
  pop tile w/ earliest gain visibility time from list
  for each adjacent tile in "add vis" list:
    this tile gains visibility at time it takes to get between tiles
    add this tile to "vis time" list

pathfinding:
tile-based fog of war good?
find disconnected regions
path smoothing
would graph be too big?

other questions:
puzzle brainstorming
work on game in summer with Matthew and/or Zach, then email TJ when further along?

changing the past and wavefunctions levels:
- what they didn't see
- better than a coin flip
- spreading coherence (objective is to see the entire map)
  - user controls electrons, but some antiprotons on map
  - in q&a explain how nature controls/sees everything (1 player game) & how we measure it, interpretations of quantum mechanics
- retroactive coherence
- do I need another level to show applications of switching particles, or does 1st level show this well enough?
- somehow show how particle can be "coherent" even if not in yellow region
- make levels introducing economic parts of game after making sure they play well in multiplayer
...
- qubits? (might not need this level)
- lucky number computing
  - must introduce "waking up" concept before this level
- CPT level to annihilate the antiproton in negative 10 seconds (only enable CPT button for this level)
- thinking in the present
  - put introduction text in "what they didn't see" repeat
  - initially show detailed animation for each move command, then short animation retracing particle's movement every time after that

amplitudes levels: (find better synonym for "part 2" such as redux?)
- better than a coin flip, part 2
- spreading coherence, part 2
- retroactive coherence, part 2

random notes:
- phrase from AI wisdom: "expand selection by radius"
- flip/mirror map for some players in multiplayer game
- only share amplitudes if option is checked for a selection of units (don't want units randomly disappearing out of nowhere)
  - if some wavefunctions don't overlap yet, send amplitudes going between those units

links:
play ogg: http://christophermpark.blogspot.com/2009/06/how-to-stream-ogg-file-using.html
